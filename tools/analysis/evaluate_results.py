#!/usr/bin/env python3
"""
Evaluate CellCDecon results by comparing to ground truth.

This script compares the inferred cell type compositions and methylation values 
from CellCDecon to the known ground truth values generated by generate_test_data.py.
"""

import numpy as np
import pandas as pd
import glob
import os
import matplotlib.pyplot as plt
import seaborn as sns
import argparse

def find_latest_output(prefix, suffix):
    """Find the latest output file with the given prefix and suffix."""
    pattern = f"{prefix}*{suffix}"
    files = glob.glob(pattern)
    if not files:
        raise FileNotFoundError(f"No files matching {pattern} found.")
    return sorted(files)[-1]  # Return the latest file

def evaluate_cell_composition(true_file, inferred_file, output_dir=None):
    """
    Evaluate the accuracy of inferred cell type compositions.
    
    Parameters:
    - true_file: Path to the true cell compositions file (.cellcomp)
    - inferred_file: Path to the inferred compositions file (.w)
    - output_dir: Directory to save plots (if None, don't save)
    
    Returns:
    - Dictionary with evaluation metrics
    """
    print("\nEvaluating cell type composition inference...")
    
    # Load true compositions
    true_comp = pd.read_csv(true_file, sep=' ')
    if 'Sample' in true_comp.columns:
        true_comp = true_comp.set_index('Sample')
    
    # Ensure all columns are numeric
    for col in true_comp.columns:
        true_comp[col] = pd.to_numeric(true_comp[col], errors='coerce')
    
    # Load inferred compositions - no header in the file
    try:
        infer_comp = pd.read_csv(inferred_file, sep='\t', header=None)
        print(f"Loaded inferred compositions with shape: {infer_comp.shape}")
    except Exception as e:
        # Try with space separator as fallback
        try:
            infer_comp = pd.read_csv(inferred_file, sep=' ', header=None)
            print(f"Loaded inferred compositions with shape: {infer_comp.shape} (using space separator)")
        except Exception as e2:
            print(f"Error loading inferred compositions: {e2}")
            print("Trying to load raw file content...")
            with open(inferred_file, 'r') as f:
                content = f.read()
            print(f"File content preview (first 100 chars): {content[:100]}")
            # Last attempt with flexible separator
            infer_comp = pd.read_csv(inferred_file, sep=None, engine='python', header=None)
            print(f"Loaded inferred compositions with shape: {infer_comp.shape} (using flexible separator)")
    
    # Display data info for debugging
    print(f"True compositions shape: {true_comp.shape}")
    print(f"Inferred compositions shape: {infer_comp.shape}")
    
    # Drop columns that are all NaN
    infer_comp = infer_comp.dropna(axis=1, how='all')
    print(f"Inferred compositions shape after dropping NaN columns: {infer_comp.shape}")
    
    # Check if there are any NaN values
    true_nan_count = true_comp.isna().sum().sum()
    infer_nan_count = infer_comp.isna().sum().sum()
    if true_nan_count > 0:
        print(f"Warning: True compositions contain {true_nan_count} NaN values")
    if infer_nan_count > 0:
        print(f"Warning: Inferred compositions contain {infer_nan_count} NaN values")
        print("NaN distribution by column:")
        for col in infer_comp.columns:
            nan_count = infer_comp[col].isna().sum()
            if nan_count > 0:
                print(f"  Column {col}: {nan_count} NaN values")
    
    # Ensure all columns are numeric
    for col in infer_comp.columns:
        infer_comp[col] = pd.to_numeric(infer_comp[col], errors='coerce')
    
    # Get the number of cell types in each dataset
    num_true_cell_types = true_comp.shape[1]
    num_inferred_cell_types = infer_comp.shape[1]
    
    print(f"Number of true cell types: {num_true_cell_types}")
    print(f"Number of inferred cell types: {num_inferred_cell_types}")
    
    # Create column names for the inferred compositions
    infer_comp.columns = [f"Inferred_CellType_{i+1}" for i in range(infer_comp.shape[1])]
    
    # Calculate correlation matrix between true and inferred cell types
    correlation_matrix = np.zeros((num_true_cell_types, num_inferred_cell_types))
    
    # Print sample values to check format
    print("\nTrue composition samples (first 3 rows):")
    print(true_comp.head(3))
    print("\nInferred composition samples (first 3 rows):")
    print(infer_comp.head(3))
    
    for i in range(num_true_cell_types):
        for j in range(num_inferred_cell_types):
            # Filter out NaN values before calculating correlation
            valid_mask = ~(np.isnan(true_comp.iloc[:, i]) | np.isnan(infer_comp.iloc[:, j]))
            if valid_mask.sum() > 1:  # Need at least 2 valid points for correlation
                # Print values for debugging
                if i == 0 and j == 0:
                    print(f"\nSample correlation values for True Cell Type 1 and Inferred Cell Type 1:")
                    print(f"True values (first 5): {true_comp.iloc[:5, i].values}")
                    print(f"Inferred values (first 5): {infer_comp.iloc[:5, j].values}")
                    
                try:
                    corr_matrix = np.corrcoef(
                        true_comp.iloc[:, i][valid_mask], 
                        infer_comp.iloc[:, j][valid_mask]
                    )
                    if corr_matrix.shape == (2, 2):
                        correlation_matrix[i, j] = corr_matrix[0, 1]
                    else:
                        print(f"Warning: Correlation matrix for cell types {i+1},{j+1} has unexpected shape: {corr_matrix.shape}")
                        correlation_matrix[i, j] = 0
                except Exception as e:
                    print(f"Error calculating correlation for cell types {i+1},{j+1}: {e}")
                    correlation_matrix[i, j] = 0
            else:
                print(f"Warning: Not enough valid data points to calculate correlation for cell types {i+1},{j+1}")
                correlation_matrix[i, j] = 0
    
    print("\nCorrelation matrix:")
    for i in range(num_true_cell_types):
        print(f"True Cell Type {i+1}: {correlation_matrix[i, :]}")
    
    # Find the best matching for each true cell type
    best_matches = {}
    match_correlations = {}
    overall_correlation = 0
    
    for i in range(num_true_cell_types):
        if i < correlation_matrix.shape[0] and correlation_matrix.shape[1] > 0:
            if np.isnan(correlation_matrix[i, :]).all():
                print(f"Warning: All correlations for True Cell Type {i+1} are NaN")
                best_match = 0  # Default to first cell type
                corr_value = 0
            else:
                # Replace NaNs with -1 for finding best match
                row_values = np.where(np.isnan(correlation_matrix[i, :]), -1, correlation_matrix[i, :])
                best_match = np.argmax(row_values)
                corr_value = correlation_matrix[i, best_match]
                if np.isnan(corr_value):
                    corr_value = 0
            
            best_matches[i] = best_match
            match_correlations[i] = corr_value
            overall_correlation += corr_value
            
            print(f"True cell type {i+1} best matches inferred cell type {best_match+1}")
            print(f"Correlation: {corr_value:.4f}")
            
            # Add the matched column to the true_comp for easy comparison
            if best_match < infer_comp.shape[1]:
                true_comp[f"Inferred_CellType_{best_match+1}"] = infer_comp.iloc[:, best_match]
        else:
            print(f"Warning: True cell type {i+1} has no corresponding inferred cell type")
            match_correlations[i] = 0
    
    if num_true_cell_types > 0:
        overall_correlation /= num_true_cell_types
        print(f"\nOverall composition correlation: {overall_correlation:.4f}")
    else:
        overall_correlation = 0
        print("\nWarning: No cell type correlations could be calculated")
    
    # Create visualizations
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)
        
        # Plot correlation heatmap
        plt.figure(figsize=(10, 8))
        sns.heatmap(correlation_matrix, annot=True, cmap='viridis', 
                    xticklabels=[f"Inferred_{i+1}" for i in range(num_inferred_cell_types)],
                    yticklabels=[f"True_{i+1}" for i in range(num_true_cell_types)])
        plt.title('Correlation between true and inferred cell types')
        plt.tight_layout()
        plt.savefig(os.path.join(output_dir, 'cell_type_correlations.png'))
        
        # Plot scatter plots for the best matches
        fig, axes = plt.subplots(1, num_true_cell_types, figsize=(5*num_true_cell_types, 5))
        if num_true_cell_types == 1:
            axes = [axes]
            
        for i in range(num_true_cell_types):
            best_match = best_matches[i]
            # Filter out NaN values for plotting
            valid_data = pd.DataFrame({
                'true': true_comp.iloc[:, i],
                'inferred': infer_comp.iloc[:, best_match]
            }).dropna()
            
            if len(valid_data) > 0:
                axes[i].scatter(valid_data['true'], valid_data['inferred'], alpha=0.7)
                axes[i].set_xlabel(f'True Cell Type {i+1} Proportion')
                axes[i].set_ylabel(f'Inferred Cell Type {best_match+1} Proportion')
                axes[i].set_title(f'Correlation: {match_correlations[i]:.4f}')
                
                # Add identity line
                min_val = min(valid_data['true'].min(), valid_data['inferred'].min())
                max_val = max(valid_data['true'].max(), valid_data['inferred'].max())
                axes[i].plot([min_val, max_val], [min_val, max_val], 'r--')
                
                # Set equal scales for x and y
                axes[i].set_xlim(0, 1)
                axes[i].set_ylim(0, 1)
            else:
                axes[i].text(0.5, 0.5, "No valid data for correlation", 
                            ha='center', va='center', transform=axes[i].transAxes)
            
        plt.tight_layout()
        plt.savefig(os.path.join(output_dir, 'cell_type_scatter_plots.png'))
        
        # Plot stacked bar charts for the original and inferred compositions
        def plot_stacked_compositions(data, columns, title, filename):
            plt.figure(figsize=(15, 8))
            data_plot = data[columns].copy()
            data_plot.index = [f"Sample_{i+1}" for i in range(len(data_plot))]
            # Fill NaN values with 0 for plotting
            data_plot = data_plot.fillna(0)
            data_plot.plot(kind='bar', stacked=True, figsize=(15, 8))
            plt.title(title)
            plt.xlabel('Sample')
            plt.ylabel('Proportion')
            plt.ylim(0, 1)
            plt.legend(title='Cell Type')
            plt.tight_layout()
            plt.savefig(os.path.join(output_dir, filename))
        
        # Plot true compositions
        true_columns = [col for col in true_comp.columns if "Inferred" not in col]
        plot_stacked_compositions(true_comp, true_columns, 
                                'True Cell Type Compositions', 
                                'true_compositions.png')
        
        # Plot inferred compositions
        infer_columns = infer_comp.columns.tolist()
        plot_stacked_compositions(infer_comp, infer_columns, 
                                'Inferred Cell Type Compositions', 
                                'inferred_compositions.png')
    
    return {
        'overall_correlation': overall_correlation,
        'match_correlations': match_correlations,
        'best_matches': best_matches
    }

def evaluate_methylation_values(true_file, inferred_file, cell_mapping, output_dir=None):
    """
    Evaluate the accuracy of inferred methylation values for each cell type.
    
    Parameters:
    - true_file: Path to the true methylation values file (.means)
    - inferred_file: Path to the inferred methylation file (.meanvar)
    - cell_mapping: Dictionary mapping true cell types to inferred cell types
    - output_dir: Directory to save plots (if None, don't save)
    
    Returns:
    - Dictionary with evaluation metrics
    """
    print("\nEvaluating cell type methylation pattern inference...")
    
    # Load true methylation means
    try:
        true_means = pd.read_csv(true_file, sep=' ')
        print(f"Loaded true methylation means with shape: {true_means.shape}")
        
        if 'Probe' in true_means.columns:
            true_means = true_means.set_index('Probe')
            print(f"Set index to 'Probe', new shape: {true_means.shape}")
        
        # Ensure all columns are numeric
        for col in true_means.columns:
            true_means[col] = pd.to_numeric(true_means[col], errors='coerce')
        
        # Check for NaN values
        true_nan_count = true_means.isna().sum().sum()
        if true_nan_count > 0:
            print(f"Warning: True methylation values contain {true_nan_count} NaN values")
    except Exception as e:
        print(f"Error loading true methylation means: {e}")
        return {
            'overall_methylation_correlation': 0,
            'methylation_correlations': {}
        }
    
    # Load inferred methylation means and variances
    try:
        try:
            inferred_data = pd.read_csv(inferred_file, sep=' ', header=None)
            print(f"Loaded inferred methylation data with shape: {inferred_data.shape}")
        except:
            # Try with tab separator as fallback
            inferred_data = pd.read_csv(inferred_file, sep='\t', header=None)
            print(f"Loaded inferred methylation data with shape: {inferred_data.shape} (using tab separator)")
        
        # Drop columns that are all NaN
        inferred_data = inferred_data.dropna(axis=1, how='all')
        print(f"Inferred methylation data shape after dropping NaN columns: {inferred_data.shape}")
        
        # Display the first few rows for debugging
        print("\nFirst few rows of inferred methylation data:")
        print(inferred_data.head())
        
        # Ensure all columns are numeric except the first (probe ID)
        for col in range(1, inferred_data.shape[1]):
            inferred_data.iloc[:, col] = pd.to_numeric(inferred_data.iloc[:, col], errors='coerce')
        
        # Check for NaN values
        inferred_nan_count = inferred_data.iloc[:, 1:].isna().sum().sum()
        if inferred_nan_count > 0:
            print(f"Warning: Inferred methylation values contain {inferred_nan_count} NaN values")
            print("NaN distribution by column:")
            for col in range(1, inferred_data.shape[1]):
                nan_count = inferred_data.iloc[:, col].isna().sum()
                if nan_count > 0:
                    print(f"  Column {col}: {nan_count} NaN values")
        
        # Extract probe IDs from the first column
        probe_ids = inferred_data.iloc[:, 0].tolist()
        
        # Number of cell types
        num_true_cell_types = len(cell_mapping)
        print(f"Number of true cell types: {num_true_cell_types}")
        print(f"Cell mapping: {cell_mapping}")
        
        # Calculate expected number of columns based on number of cell types
        expected_columns = 1 + (num_true_cell_types * 2) + 2  # Probe ID + (mean,var) for each cell type + observed mean & var
        actual_columns = inferred_data.shape[1]
        
        print(f"Expected columns: {expected_columns}, Actual columns: {actual_columns}")
        
        if actual_columns != expected_columns:
            print(f"Warning: Expected {expected_columns} columns but found {actual_columns} columns")
            print("Column explanation: 1 (probe ID) + 2 columns per cell type (mean, var) + 2 (observed mean, var)")
        
        # Extract only the mean values from the inferred data (alternating mean, variance)
        inferred_means = pd.DataFrame()
        
        # The format of the meanvar file is:
        # probe_id mean1 var1 mean2 var2 mean3 var3 ... observed_mean observed_var
        # Each cell type has a mean and variance column, so we need to extract columns 1, 3, 5, etc.
        for i in range(num_true_cell_types):
            # Means are in columns 1, 3, 5, etc. for cell types 1, 2, 3, etc.
            # We need to ensure we don't go out of bounds
            col_idx = 1 + i*2
            if col_idx < inferred_data.shape[1] - 2:  # -2 to account for observed mean and var at the end
                inferred_means[f"Inferred_CellType_{i+1}_Mean"] = inferred_data.iloc[:, col_idx]
            else:
                print(f"Warning: Column index {col_idx} is out of bounds for inferred data")
        
        inferred_means['Probe'] = probe_ids
        inferred_means = inferred_means.set_index('Probe')
        
        # Print sample values from both dataframes
        print("\nSample values from true and inferred means:")
        shared_probes = list(set(true_means.index) & set(inferred_means.index))
        if shared_probes:
            sample_probe = shared_probes[0]
            print(f"Probe {sample_probe}:")
            print(f"True values: {true_means.loc[sample_probe].values}")
            print(f"Inferred values: {inferred_means.loc[sample_probe].values}")
        
        # Calculate correlations for matched cell types
        methylation_correlations = {}
        overall_methylation_correlation = 0
        
        for true_type, inferred_type in cell_mapping.items():
            try:
                true_col = f"CellType_{true_type+1}" if f"CellType_{true_type+1}" in true_means.columns else true_type
                inferred_col = f"Inferred_CellType_{inferred_type+1}_Mean"
                
                print(f"\nComparing true column '{true_col}' with inferred column '{inferred_col}'")
                
                if inferred_col in inferred_means.columns:
                    # Create a DataFrame with both columns for probes that exist in both datasets
                    shared_probes = list(set(true_means.index) & set(inferred_means.index))
                    print(f"Number of shared probes: {len(shared_probes)}")
                    
                    if not shared_probes:
                        print("No shared probes found between true and inferred data")
                        methylation_correlations[true_type] = 0
                        continue
                    
                    comparison_df = pd.DataFrame({
                        'true': true_means.loc[shared_probes, true_col],
                        'inferred': inferred_means.loc[shared_probes, inferred_col]
                    })
                    
                    # Filter out NaN values
                    comparison_df = comparison_df.dropna()
                    print(f"Number of valid data points after dropping NaNs: {len(comparison_df)}")
                    
                    if len(comparison_df) > 1:  # Need at least 2 valid points for correlation
                        correlation = np.corrcoef(
                            comparison_df['true'], 
                            comparison_df['inferred']
                        )[0, 1]
                        
                        # Handle NaN correlation
                        if np.isnan(correlation):
                            print("Warning: Correlation calculation resulted in NaN")
                            print("Sample values:")
                            print(comparison_df.head())
                            correlation = 0
                    else:
                        print("Not enough valid data points to calculate correlation")
                        correlation = 0
                        
                    methylation_correlations[true_type] = correlation
                    overall_methylation_correlation += correlation
                    
                    print(f"Cell type {true_type+1} methylation correlation: {correlation:.4f}")
                else:
                    print(f"Warning: Inferred column {inferred_col} not found in the data")
                    print(f"Available columns: {inferred_means.columns}")
                    methylation_correlations[true_type] = 0
            except Exception as e:
                print(f"Error calculating correlation for cell type {true_type+1}: {e}")
                methylation_correlations[true_type] = 0
        
        if cell_mapping and any(v != 0 for v in methylation_correlations.values()):
            overall_methylation_correlation /= len(cell_mapping)
            print(f"\nOverall methylation pattern correlation: {overall_methylation_correlation:.4f}")
        else:
            overall_methylation_correlation = 0
            print("\nWarning: No valid cell mappings found or all correlations are zero")
        
        # Create visualizations
        if output_dir and cell_mapping:
            os.makedirs(output_dir, exist_ok=True)
            
            # Plot methylation pattern correlations
            fig, axes = plt.subplots(1, num_true_cell_types, figsize=(5*num_true_cell_types, 5))
            if num_true_cell_types == 1:
                axes = [axes]
                
            for true_type, inferred_type in cell_mapping.items():
                true_col = f"CellType_{true_type+1}" if f"CellType_{true_type+1}" in true_means.columns else true_type
                inferred_col = f"Inferred_CellType_{inferred_type+1}_Mean"
                
                if inferred_col in inferred_means.columns:
                    # Filter out NaN values for plotting
                    valid_data = pd.DataFrame({
                        'true': true_means[true_col],
                        'inferred': inferred_means[inferred_col]
                    }).dropna()
                    
                    if len(valid_data) > 0 and true_type < len(axes):
                        axes[true_type].scatter(valid_data['true'], valid_data['inferred'], alpha=0.3)
                        axes[true_type].set_xlabel(f'True Cell Type {true_type+1} Methylation')
                        axes[true_type].set_ylabel(f'Inferred Cell Type {inferred_type+1} Methylation')
                        axes[true_type].set_title(f'Correlation: {methylation_correlations[true_type]:.4f}')
                        
                        # Add identity line
                        axes[true_type].plot([0, 1], [0, 1], 'r--')
                        
                        # Set equal scales
                        axes[true_type].set_xlim(0, 1)
                        axes[true_type].set_ylim(0, 1)
                    elif true_type < len(axes):
                        axes[true_type].text(0.5, 0.5, "No valid data for correlation", 
                                           ha='center', va='center', transform=axes[true_type].transAxes)
                elif true_type < len(axes):
                    axes[true_type].text(0.5, 0.5, f"Column {inferred_col} not found", 
                                       ha='center', va='center', transform=axes[true_type].transAxes)
                
            plt.tight_layout()
            plt.savefig(os.path.join(output_dir, 'methylation_scatter_plots.png'))
            
            # Plot true vs inferred methylation patterns for a few probes
            try:
                num_sample_probes = min(10, len(true_means))
                sample_probes = true_means.sample(n=num_sample_probes).index.tolist()
                
                for probe in sample_probes:
                    plt.figure(figsize=(10, 6))
                    
                    # Get true methylation values for this probe across cell types
                    true_values = []
                    for i in range(num_true_cell_types):
                        col_name = f"CellType_{i+1}" if f"CellType_{i+1}" in true_means.columns else i
                        if col_name in true_means.columns:
                            try:
                                value = float(true_means.loc[probe, col_name])
                                true_values.append(value if not np.isnan(value) else 0)
                            except:
                                true_values.append(0)
                        else:
                            true_values.append(0)
                    
                    # Get inferred methylation values using the cell type mapping
                    inferred_values = []
                    for i in range(num_true_cell_types):
                        if i in cell_mapping:
                            col_name = f"Inferred_CellType_{cell_mapping[i]+1}_Mean"
                            if col_name in inferred_means.columns and probe in inferred_means.index:
                                try:
                                    value = float(inferred_means.loc[probe, col_name])
                                    inferred_values.append(value if not np.isnan(value) else 0)
                                except:
                                    inferred_values.append(0)
                            else:
                                inferred_values.append(0)
                        else:
                            inferred_values.append(0)
                    
                    x = np.arange(num_true_cell_types)
                    width = 0.35
                    
                    plt.bar(x - width/2, true_values, width, label='True')
                    plt.bar(x + width/2, inferred_values, width, label='Inferred')
                    
                    plt.xlabel('Cell Type')
                    plt.ylabel('Methylation Value')
                    plt.title(f'Probe {probe} Methylation Pattern')
                    plt.xticks(x, [f'Type {i+1}' for i in range(num_true_cell_types)])
                    plt.ylim(0, 1)
                    plt.legend()
                    
                    plt.tight_layout()
                    plt.savefig(os.path.join(output_dir, f'probe_{probe}_comparison.png'))
            except Exception as e:
                print(f"Warning: Could not generate probe comparison plots: {e}")
        
        return {
            'overall_methylation_correlation': overall_methylation_correlation,
            'methylation_correlations': methylation_correlations
        }
    
    except Exception as e:
        print(f"Error evaluating methylation values: {e}")
        return {
            'overall_methylation_correlation': 0,
            'methylation_correlations': {}
        }

def main():
    parser = argparse.ArgumentParser(description="Evaluate CellCDecon results against ground truth")
    parser.add_argument("--base-file", type=str, required=True, 
                        help="Base filename (e.g., synthetic_data/synthetic_methylation.txt)")
    parser.add_argument("--output-dir", type=str, default="evaluation_results", 
                        help="Directory to save evaluation results and plots")
    
    args = parser.parse_args()
    
    base_file = args.base_file
    output_dir = args.output_dir
    
    # Verify base file exists
    if not os.path.exists(base_file):
        print(f"Error: Base file {base_file} not found.")
        return
    
    # Find the true and inferred files
    true_comp_file = f"{base_file}.cellcomp"
    true_means_file = f"{base_file}.means"
    
    # Check if true files exist
    if not os.path.exists(true_comp_file):
        print(f"Error: True composition file {true_comp_file} not found.")
        return
    
    if not os.path.exists(true_means_file):
        print(f"Error: True methylation file {true_means_file} not found.")
        return
    
    # Find the latest CellCDecon output files
    base_dir = os.path.dirname(base_file)
    base_name = os.path.basename(base_file)
    
    inferred_files = glob.glob(f"{base_dir}/{base_name}.k*.seed*.w")
    if not inferred_files:
        print(f"Error: No CellCDecon output files found for {base_file}")
        print("Please run CellCDecon first to generate output files.")
        return
    
    # Sort by modification time and get the latest
    inferred_files.sort(key=os.path.getmtime)
    latest_inferred = inferred_files[-1]
    
    # Extract k and seed values from the filename
    parts = latest_inferred.split('.')
    try:
        k_part = next(part for part in parts if part.startswith('k'))
        seed_part = next(part for part in parts if part.startswith('seed'))
    except StopIteration:
        print(f"Warning: Could not extract k and seed values from filename {latest_inferred}")
        k_part = "k?"
        seed_part = "seed?"
    
    # Construct the other filenames
    inferred_comp_file = latest_inferred
    inferred_means_file = latest_inferred.replace('.w', '.meanvar')
    
    print(f"True composition file: {true_comp_file}")
    print(f"True methylation file: {true_means_file}")
    print(f"Inferred composition file: {inferred_comp_file}")
    print(f"Inferred methylation file: {inferred_means_file}")
    
    # Evaluate the results
    os.makedirs(output_dir, exist_ok=True)
    
    try:
        # Evaluate cell type compositions
        comp_results = evaluate_cell_composition(
            true_comp_file, inferred_comp_file, output_dir)
        
        # Evaluate methylation values using the cell type mapping from composition evaluation
        methylation_results = evaluate_methylation_values(
            true_means_file, inferred_means_file, comp_results['best_matches'], output_dir)
        
        # Save the overall results
        results_summary = {
            'composition_correlation': comp_results['overall_correlation'],
            'methylation_correlation': methylation_results['overall_methylation_correlation'],
            'cell_type_mapping': {f"True_{k+1}": f"Inferred_{v+1}" for k, v in comp_results['best_matches'].items()},
            'composition_correlations': {f"Type_{k+1}": v for k, v in comp_results['match_correlations'].items()},
            'methylation_correlations': {f"Type_{k+1}": v for k, v in methylation_results['methylation_correlations'].items()}
        }
        
        with open(os.path.join(output_dir, 'evaluation_summary.txt'), 'w') as f:
            f.write("CellCDecon Evaluation Summary\n")
            f.write("============================\n\n")
            
            f.write(f"Overall composition correlation: {results_summary['composition_correlation']:.4f}\n")
            f.write(f"Overall methylation correlation: {results_summary['methylation_correlation']:.4f}\n\n")
            
            f.write("Cell Type Mapping:\n")
            for true_type, inferred_type in results_summary['cell_type_mapping'].items():
                f.write(f"  {true_type} -> {inferred_type}\n")
            
            f.write("\nComposition Correlations by Cell Type:\n")
            for cell_type, corr in results_summary['composition_correlations'].items():
                f.write(f"  {cell_type}: {corr:.4f}\n")
                
            f.write("\nMethylation Correlations by Cell Type:\n")
            for cell_type, corr in results_summary['methylation_correlations'].items():
                f.write(f"  {cell_type}: {corr:.4f}\n")
        
        print(f"\nEvaluation complete. Results saved to {output_dir}")
    
    except Exception as e:
        print(f"Error during evaluation: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main() 